# Effizienz und Rationalität 

## Individuelles Entscheidungsproblem

Das Folgende ist fast wörtlich aus @Detel07_Soz S. 20 übernommen.

### Basisschema der Handlungserklärung

1. Person $S$ wünscht, Ziel $Z$ zu realisieren.

2. $S$ glaubt, die Handlung $H$ sei ein Mittel, um $Z$ zu realisieren.

3. **$S$ vollzieht Handlung $H$**.


Das Basisschema ist noch unvollständig:

- Was ist, wenn es für $S$ bessere Handlungen als $H$ gibt, $Z$ zu
realisieren? Dann wäre es nicht vernünftig, $H$ zu vollziehen.
-  Was ist, wenn es $S$ $H$ gar nicht vollziehen kann?
-  Was ist, wenn $H$ mit negativen Folgen einhergeht, die schlimmer
sind, als $Z$ nicht zu realisieren?
-  Was ist, wenn $S$ noch weitere Ziele realisieren will, die mit $Z$
nicht vereinbar sind?

$\Rightarrow$ **erweitertes Schema der Handlungserklärung**


### Erweitertes Schema der Handlungserklärung

1. $S$ hat die Absicht, Ziel $Z$ zu realisieren.

2. $S$ glaubt, dass, wenn sie Handlung $H$ vollzieht, sie somit $Z$
realisieren kann.

3. $S$ glaubt in der Lage zu sein, $Z$ zu realisieren und $H$ zu vollziehen.

4. $S$ weiß, wie man $Z$ realisiert und $H$ vollzieht.

4. $S$ glaubt nicht, dass es etwas Besseres gibt als $H$, um $Z$ zu
realisieren.

5. $S$ glaubt nicht, dass der Vollzug von $H$ Folgen hat, die schlimmer
sind als nicht $Z$ realisieren zu können.

6. $S$ hat nicht die Absicht, ein Ziel zu realisieren, von dem $S$
weiß, dass es unvereinbar damit ist, $Z$ zu realisieren, und das
sie $Z$ gegenüber vorzieht.

7. **$S$ vollzieht Handlung $H$.**

### Zwischenfazit

- Erklärungen rationaler Handlungen unterstellen nicht zwangsläufig,
dass die handelnde Person "alles richtig"  macht. 
-  Insbesondere lässt es beschränkte Handlungsmöglichkeiten zu und unvollständige
oder fehlerhafte Informationslagen.
- Das **Rationalprinzip** ist weniger eine Behauptung über die handelnde
Person, sondern ein Schema, eine **"Grammatik" der Erklärung**.


### Rationales Handeln als Nutzenmaximierung


- Darstellung der Ziele eines Individuums mittels Nutzenfunktionen: $U=U(x_1, x_2, \dots, x_n)$.

- Der Nutzen hängt ab von den konsumierten Gütern oder sonstigen Umständen $x_i$

- Zur Vereinfachung: Beschränkung auf wenige Güter


- Ein Beispiel: $U(x_1, x_2)=\frac{1}{2} \sqrt{x_1\times x_2}$

#### 3D-Darstellung: Nutzengebirge

```{r echo=F, warning=F, message=F, cache=F, eval=T}

library(tidyverse)
library(plotly)

f <- function(x1, x2){x1+x2}

x1a <- 0
x1b <- 100

x2a <- 0
x2b <- 100

x1 <- seq(x1a, x1b)
x2 <- seq(x2a, x2b)  


f <- function(x1, x2){.5*(x1*x2)^.5}


u <- outer(x1, x2, f)

p <- plot_ly(z = u, type = "surface", opacity=.5) %>%
 #
  layout(scene = list(xaxis = list(title ="x<sub>1</sub>", showticklabels = FALSE), yaxis = list(title = "x<sub>2</sub>", showticklabels = FALSE), zaxis = list(title = "U", showticklabels = FALSE))) %>%
   config(displaylogo = FALSE,
          scrollZoom = F) %>%            add_surface(
      contours = list(
      z = list(
      show=T,
      usecolormap=T,
      highlightcolor="#ff0000",
      project=list(z=TRUE)
      )
    )
  )%>% layout(
    scene = list(
      camera=list(
        eye = list(x=-1, y=-2, z=.2)
        )
      )
  )%>% 
  hide_colorbar()

p

```

#### 2D-Darstellung: Kombinationen von beiden Gütern, die zu gleichem Nutzenniveau führen


```{r echo=F, message=F, warning=F, cache=F}
p <- plot_ly(z = u, type = "contour", opacity=.5) %>%
  layout(xaxis = list(title ="x<sub>1</sub>", showticklabels = FALSE), yaxis = list(title = "x<sub>2</sub>", showticklabels = FALSE)) %>%
   config(displaylogo = FALSE) %>%
  hide_colorbar()

p
```
[Hier Nutzenfunktion und Indifferenzkurven]::

```{python}
#| message: false
#| warning: false
#| output: false

from lets_plot import *
import numpy as np
from sympy import symbols, Eq, solve, lambdify, latex

# Setup Lets-Plot for HTML output
LetsPlot.setup_html()

# Define the symbols and the equation
x1, x2, U = symbols('x1 x2 U')
equation = Eq(U,.5*(x1*x2)**.5)

# Solve for x2 and lambdify the solution
solution_x2 = solve(equation, x2)[0]
x2_func = lambdify((x1, U), solution_x2)

# Define specific values for U
U_value = 3
U_values = [U_value - 1, U_value, U_value + 1]
colors = ['red', 'blue', 'green']
labels = ['U=2', 'U=3', 'U=4']

# Create data with values from 0 to 6 in steps of 0.1
x_values = np.arange(.5, 4.1, 0.1)
data = {'x': x_values.tolist()}

# Initialize the plot
plot = ggplot()

# Add curves using a loop and annotate each curve
for i, u in enumerate(U_values):
    plot += geom_function(aes('x'), data=data, fun=lambda t, u=u: x2_func(t, u), color=colors[i])
    # Annotate each curve at a specific point (e.g., x=4)
    y_value = x2_func(4, u)
    plot += geom_text(x=4.5, y=y_value, label= labels[i], size=6
)

# Add title and labels
plot += ggtitle(f'Indifferenzkurven zu U') + \
        labs(x='\( x_1 \)', y='\(x_2\)', caption='Caption') + \
        theme_light()

# Display the plot
# plot.show()

ggsave(plot, filename='plot.svg')
```

![Indifferenzkurven](lets-plot-images/plot.svg)

#### Indifferenzkurven und Budgetrestriktionen

Nutzenfunktion: $U(x_1, x_2)=x_1\times x_2$

Indifferenzkurve: $x_2=\frac{\bar{U}}{x_1}$

Budgetrestriktion: $I=p_1 x_1+p_2 x_2$

Budgetlinie: $x_2=\frac{I}{p_2}- \frac{p_1}{p_2}x_1$



```{r echo=F, warning=F, message=F, cache=F}
# Bibliotheken laden
library(tidyverse)
library(latex2exp)

# Funktionen definieren

x <- 0:10

I_1 <- function(x) 10/x
I_2 <- function(x) 25/x
I_3 <- function(x) (5*7.5)/x

b1 <- function(x) 10-x
b2 <- function(x) 10-(2/3)*x


#Gleichgewichtsmenge x1^0
x10 <- uniroot(function(x) -25/x^2 + 1, range(x))$root

#Gleichgewichtsmenge x20

x20 <- b1(x10)

#Gleichgewichtsmenge x1^1
x11 <- uniroot(function(x) -(5*7.5)/x^2 + 2/3, range(x))$root


# Chart

chart <- ggplot() +
  stat_function(aes(color = "I_1"), fun = I_1, xlim = c(uniroot(function(x) I_1(x) - 18, range(x))$root,18))+
   annotate(geom = "text", x=18, y=I_1(18), hjust=-0.4, label=expression(I[1]),color = "grey30")+
  #
  stat_function(aes(color = "I_2"), fun = I_2, xlim = c(uniroot(function(x) I_2(x) - 18, range(x))$root,18)) +
   annotate(geom = "text", x=18, y=I_2(18), hjust=-0.4, label=expression(I[2]),color = "grey30")+
  #
  stat_function(aes(color = "I_3"), fun = I_3, xlim = c(uniroot(function(x) I_3(x) - 18, range(x))$root,18)) +
  annotate(geom = "text", x=18, y=I_3(18), hjust=-0.4, label=expression(I[3]),color = "grey30")+
  #
  stat_function(aes(color = "budget"), fun = b1, xlim=c(0,10))+
  stat_function(aes(color = "budget"), fun = b2, linetype="dashed", xlim=c(0,15))+
  #
  annotate("segment", x = x10, xend = x10, y = 0, yend = x20,
           linetype = "dashed") +
  #
  annotate("segment", x = 0, xend = x11, y = x20, yend = x20,
           linetype = "dashed") +
  #
  annotate("segment", x = x10, xend = x10, y = 0, yend = x20,
           linetype = "dashed") +
  #
    annotate("segment", x = x11, xend = x11, y = 0, yend = x20,
           linetype = "dashed") +
  #
  scale_color_manual(values=c("red", "green", "green", "green"))+
  #scale_fill_manual(values=c("green", "orange"))+
  scale_x_continuous(expand = c(0, 0), 
                    breaks = c(0, x10, x11, 10, 15), labels = expression("0",x[1]^0, x[1]^1, frac(I^0, p[1]^0), frac(I^0, p[1]^1) ),
                     limits = c(0, 20)) +
  scale_y_continuous(expand = c(0, 0), 
                     breaks = c(0,x20, 10), labels = c("0", latex2exp::TeX(r"($x_2^0=x_2^1$)"), latex2exp::TeX(r"($\frac{I^0}{p_1^0}$)") ),
                     limits = c(0,20)) +
  theme_classic() +
  theme(panel.grid = element_blank(),
        legend.position = "none", #Damit Legende unterdrückt.
       ) +
  theme(axis.line = element_line(arrow = arrow(type='closed', length = unit(5,'pt'))))+
  labs(x = latex2exp::TeX(r'($x_1$)'), y = latex2exp::TeX(r'($x_2$)'), 
       color = NULL, fill = NULL)
    chart

```



#### Das Verhältnis zwischen Rationalität und Nutzenmaximierung

```{python}
#| warning: false
#| message: false
#| output: false

from graphviz import Source
from IPython.display import display

dot = '''
digraph clusters_example {
  graph [rankdir=LR]

  node [style=filled, color=white, fixedsize=true, width=2.5, height=1.2]

  subgraph cluster_3 {
    style=filled; color="#00ffff30"
    c1 [label="Eigenschaften des\n Entscheidungsverhaltens"]
    c2 [label="Rationalität"]
    c1 -> c2
    label = "Axiomatischer Rationalitätsbegriff"
  }

  subgraph cluster_2 {
    style=filled; color="#00ffff65"
    b1 [label="(Rationale) Entscheidung"]
    b2 [label="Nutzenfunktion"]
    b1 -> b2
    label = "Offenbarte Präferenzen"
  }

  subgraph cluster_1 {
    style=filled; color="#00ffff"
    a1 [label="Nutzenfunktion"]
    a2 [label="Rationale Entscheidung"]
    a1 -> a2
    label = "Hedonistischer Nutzenbegriff"
  }
}
'''

src = Source(dot)
# display(src)

#Datei erzeugen 
src.format = 'svg'  # Format setzen
src.render(filename='Rationalitaet', cleanup=True)  # Erzeugt output.svg
```

![Nutzen und Rationalität](Rationalitaet.svg)

## Gesellschaftliches Entscheidungsproblem

### Pareto-Verbesserungen und Pareto-Effizienz

[Edgeworth]::

[Hier auch potenzielle Pareto-Verbesserungen]::

### Auswahl zwischen verschiedenen effizienten Zuständen

## Individuelle Rationalität und gesellschaftliche Effizienz

[Hier Spieltheorie]::